<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bikes And</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400&display=swap');
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{overflow:hidden;height:100%;width:100%}
  body{cursor:crosshair;background:#FFF;display:flex;flex-direction:column}
  .grid-container{
    flex:1;
    display:grid;
    grid-template-columns:repeat(9,1fr);
    grid-template-rows:repeat(7,1fr);
    width:100%;
    min-height:0;
    padding:8px;
  }
  .bike-cell{position:relative;overflow:visible;min-height:0}
  .bike-cell svg{width:100%;height:100%;overflow:visible;display:block}
  .title-bar{height:28px;flex-shrink:0;display:flex;align-items:center;justify-content:center;padding-bottom:4px}
  .title-bar a{font-family:'Inter',sans-serif;font-size:24px;font-weight:400;color:#1a1a1a;text-decoration:none;letter-spacing:.02em}
  .title-bar a:hover{opacity:.6}
  .title-bracket{font-family:'Inter',sans-serif;font-size:24px;font-weight:400;color:#ccc;letter-spacing:.02em}
  .motion-prompt{position:fixed;inset:0;z-index:100;background:#FFF;display:none;flex-direction:column;align-items:center;justify-content:center;gap:16px;font-family:'DM Mono','SF Mono',monospace}
  .motion-prompt.visible{display:flex}
  .motion-prompt p{font-size:11px;letter-spacing:.15em;text-transform:uppercase;color:#888}
  .motion-prompt button{font-family:inherit;font-size:11px;letter-spacing:.2em;text-transform:uppercase;padding:14px 28px;border:1.5px solid #1a1a1a;background:none;cursor:pointer;color:#1a1a1a;transition:background .2s,color .2s}
  .motion-prompt button:active{background:#1a1a1a;color:#fff}
  @media(max-width:768px){
    .grid-container{grid-template-columns:repeat(7,1fr);grid-template-rows:repeat(9,1fr)}
    .title-bar a,.title-bracket{font-size:20px}
  }
</style>
</head>
<body>
<div class="motion-prompt" id="motionPrompt">
  <p>Tilt your phone to reshape</p>
  <button id="motionBtn">Enable Motion</button>
</div>
<div class="grid-container" id="grid"></div>
<div class="title-bar">
  <a href="https://www.strava.com/" target="_blank" rel="noopener">Bikes and</a>
  <span class="title-bracket">&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]</span>
</div>

<script>
const COLS=9,ROWS=7,BIKE_COUNT=COLS*ROWS;
const WPAL=[
  {r:255,g:85,b:68},{r:255,g:187,b:0},{r:255,g:187,b:68},
  {r:68,g:136,b:255},{r:0,g:102,b:255},{r:255,g:170,b:255},{r:255,g:85,b:68}
];
function lerpC(a,b,t){t=Math.max(0,Math.min(1,t));return`rgb(${Math.round(a.r+(b.r-a.r)*t)},${Math.round(a.g+(b.g-a.g)*t)},${Math.round(a.b+(b.b-a.b)*t)})`}
function getWheelColor(col,row,isRear,t,smx,smy){
  const gcx=smx*COLS,gcy=smy*ROWS;
  const dx=col-gcx,dy=row-gcy;
  const gd=Math.sqrt(dx*dx+dy*dy);
  const phase=(gd*0.4+t*0.08+(isRear?0:0.5))%1;
  const idx=phase*(WPAL.length-1);
  const i=Math.floor(Math.abs(idx))%(WPAL.length-1);
  const f=Math.abs(idx)-Math.floor(Math.abs(idx));
  return lerpC(WPAL[i],WPAL[Math.min(i+1,WPAL.length-1)],f);
}

const DARK='#0a0a0a',SEGMENTS=15;
let input={x:.5,y:.5},smooth={x:.5,y:.5},useGyro=false,time=0;
const bikes=[];

function lerp(a,b,t){return a+(b-a)*t}
function clamp(v,lo,hi){return Math.min(Math.max(v,lo),hi)}
function dist(x1,y1,x2,y2){return Math.sqrt((x2-x1)**2+(y2-y1)**2)}
function vertexNoise(seed,i,t){const s=seed*137.5+i*43.7;return Math.sin(s+t*0.37)*0.4+Math.sin(s*1.73+t*0.59)*0.35+Math.sin(s*2.91+t*0.83)*0.25}
function irregularNgon(cx,cy,r,n,rot,seed,t){
  let p='';const sa=Math.PI*2/n;
  for(let i=0;i<n;i++){const ba=rot+i*sa;const aO=vertexNoise(seed,i,t)*sa*0.1;const rO=1+vertexNoise(seed+50,i,t)*0.1;p+=`${cx+Math.cos(ba+aO)*r*rO},${cy+Math.sin(ba+aO)*r*rO} `}
  return p.trim();
}
function setLine(el,x1,y1,x2,y2){el.setAttribute('x1',x1);el.setAttribute('y1',y1);el.setAttribute('x2',x2);el.setAttribute('y2',y2)}
function normalize(x,y){const l=Math.sqrt(x*x+y*y)||1;return{x:x/l,y:y/l}}

function createBikeSVG(i){
  const ns='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(ns,'svg');
  svg.setAttribute('xmlns',ns);svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  const mk=(tag,attrs)=>{const e=document.createElementNS(ns,tag);for(const[k,v]of Object.entries(attrs))e.setAttribute(k,v);return e};
  const els={};
  els.wheelRear=mk('polygon',{});
  els.wheelFront=mk('polygon',{});
  els.rearTriangle=mk('polygon',{fill:'none',stroke:DARK,'stroke-linejoin':'round'});
  els.mainTriangle=mk('polygon',{fill:'none',stroke:DARK,'stroke-linejoin':'round'});
  els.fork=mk('line',{'stroke-linecap':'round',stroke:DARK});
  els.seatPost=mk('line',{'stroke-linecap':'round',stroke:DARK});
  els.seatLower=mk('line',{'stroke-linecap':'round',stroke:DARK});
  els.seatUpper=mk('line',{'stroke-linecap':'round',stroke:DARK});
  els.crankset=mk('polygon',{});
  els.stem=mk('line',{'stroke-linecap':'round',stroke:DARK});
  els.dropBar=mk('path',{fill:'none','stroke-linecap':'round',stroke:DARK});
  [els.wheelRear,els.wheelFront,els.rearTriangle,els.mainTriangle,
   els.fork,els.seatPost,els.seatLower,els.seatUpper,
   els.crankset,els.stem,els.dropBar].forEach(e=>svg.appendChild(e));
  return{svg,els,seed:i*7+1,col:i%COLS,row:Math.floor(i/COLS)};
}

const gridEl=document.getElementById('grid');
for(let i=0;i<BIKE_COUNT;i++){
  const cell=document.createElement('div');cell.className='bike-cell';
  const bike=createBikeSVG(i);cell.appendChild(bike.svg);gridEl.appendChild(cell);bikes.push(bike);
}

function updateCellRects(){
  document.querySelectorAll('.bike-cell').forEach((cell,i)=>{
    const r=cell.getBoundingClientRect();const a=r.width/r.height;
    let vbW,vbH;if(a>1){vbH=400;vbW=400*a}else{vbW=400;vbH=400/a}
    bikes[i].baseVbW=vbW;bikes[i].baseVbH=vbH;bikes[i].cellRect=r;
  });
}
window.addEventListener('resize',updateCellRects);
// Delay initial measure to ensure layout is settled
requestAnimationFrame(()=>{requestAnimationFrame(updateCellRects)});

function cursorInVB(bike,smx,smy){
  const r=bike.cellRect;if(!r)return{x:bike.baseVbW/2,y:bike.baseVbH/2};
  return{x:((smx*window.innerWidth-r.left)/r.width)*bike.baseVbW,y:((smy*window.innerHeight-r.top)/r.height)*bike.baseVbH};
}
// 50% wider falloff: multiplier 1.33 (was 2.0)
function wheelProximity(wx,wy,cx,cy,vbW,vbH){
  const d=dist(wx,wy,cx,cy)/Math.sqrt(vbW*vbW+vbH*vbH);
  const inf=clamp(1-d*1.33,0,1);return inf*inf*(3-2*inf);
}
function getViewBoxDrift(bike,mx,my){
  const r=bike.cellRect;if(!r)return{dx:0,dy:0};
  const cx=mx*window.innerWidth,cy=my*window.innerHeight;
  const ccx=r.left+r.width/2,ccy=r.top+r.height/2;
  const dx=cx-ccx,dy=cy-ccy,len=Math.sqrt(dx*dx+dy*dy)||1;
  const diag=Math.sqrt(window.innerWidth**2+window.innerHeight**2);
  const cl=clamp(1-Math.sqrt((cx-ccx)**2+(cy-ccy)**2)/diag*3.5,0,1);
  const pr=cl*cl*(3-2*cl);
  return{dx:(dx/len)*bike.baseVbW*0.15*pr,dy:(dy/len)*bike.baseVbH*0.15*pr};
}
function repelFromCircle(px,py,cx,cy,radius,margin){
  const d=dist(px,py,cx,cy),boundary=radius+margin;
  if(d>=boundary)return{x:px,y:py};
  const pen=1-d/boundary;let dx=px-cx,dy=py-cy;const dl=Math.sqrt(dx*dx+dy*dy)||1;
  const push=boundary*pen*pen*0.8+(boundary-d);
  return{x:px+(dx/dl)*push,y:py+(dy/dl)*push};
}
function repelBoth(px,py,rax,ray,rR,fax,fay,fR,m){
  let p=repelFromCircle(px,py,rax,ray,rR,m);return repelFromCircle(p.x,p.y,fax,fay,fR,m);
}

function updateBike(bike,smx,smy,t){
  const{els,seed,baseVbW:vbW,baseVbH:vbH,col,row}=bike;
  if(!vbW||!vbH)return;

  const drift=getViewBoxDrift(bike,smooth.x,smooth.y);
  bike.svg.setAttribute('viewBox',`${-drift.dx} ${-drift.dy} ${vbW} ${vbH}`);

  const cur=cursorInVB(bike,smooth.x,smooth.y);
  const cxVB=vbW/2,cyVB=vbH/2;

  const baseSpread=vbW*0.28,baseY=cyVB+vbH*0.05;
  const baseRearX=cxVB-baseSpread/2,baseFrontX=cxVB+baseSpread/2,baseWheelR=vbH*0.1;

  const rearProx=wheelProximity(baseRearX,baseY,cur.x,cur.y,vbW,vbH);
  const frontProx=wheelProximity(baseFrontX,baseY,cur.x,cur.y,vbW,vbH);

  let rR=clamp(baseWheelR*(1.25+(3.2-1.25)*rearProx),vbH*0.04,vbH*0.48);
  let rF=clamp(baseWheelR*(1.25+(3.2-1.25)*frontProx),vbH*0.04,vbH*0.48);

  let spread=baseSpread;
  let eg=spread-rR-rF;
  if(eg>vbH*0.12)spread=rR+rF+vbH*0.12;else if(eg<vbH*0.015)spread=rR+rF+vbH*0.015;

  const rax=cxVB-spread/2,fax=cxVB+spread/2,ray=baseY,fay=baseY;
  const avgR=(rR+rF)/2;
  const sw=clamp(avgR*0.09,1.5,vbH*0.045);
  const rm=sw*0.5;

  const frameCeiling=Math.min(ray-rR,fay-rF)-avgR*0.05;

  // BB
  const rearEdge=rax+rR,frontEdge=fax-rF;
  const bbX=(rearEdge+frontEdge)/2;
  const bbY=Math.min(baseY+avgR*0.25,ray+rR*0.3);
  let bb=repelBoth(bbX,bbY,rax,ray,rR,fax,fay,rF,rm);

  // Seat joint
  const seatAng=73*Math.PI/180,stLen=avgR*0.85;
  let sjX=bb.x-Math.cos(seatAng)*stLen,sjY=bb.y-Math.sin(seatAng)*stLen;
  sjY=Math.min(sjY,frameCeiling);
  let sj=repelBoth(sjX,sjY,rax,ray,rR,fax,fay,rF,rm);
  sj.y=Math.min(sj.y,frameCeiling);

  // Head tube
  const ttLen=spread*0.5;
  const tangentSlope=(fay-rF-(ray-rR))/(fax-rax);
  let htX=sj.x+ttLen,htY=sj.y+tangentSlope*ttLen;
  htY=Math.min(htY,frameCeiling);
  let ht=repelBoth(htX,htY,rax,ray,rR,fax,fay,rF,rm);
  ht.y=Math.min(ht.y,frameCeiling);
  const ttA=Math.atan2(ht.y-sj.y,ht.x-sj.x);
  if(ttA>20*Math.PI/180)ht.y=sj.y+Math.tan(20*Math.PI/180)*(ht.x-sj.x);

  // Fork 25% outside
  let headX=ht.x,headY=ht.y;
  const forkL=dist(headX,headY,fax,fay);
  const fkd=normalize(fax-headX,fay-headY);
  if(forkL-rF<forkL*0.25&&forkL>0){
    const need=rF+forkL*0.25;
    headX=fax-fkd.x*need;headY=fay-fkd.y*need;
    headY=Math.min(headY,frameCeiling);
  }

  // Stem: bisector of fork + downtube angle
  const forkDir=normalize(fax-headX,fay-headY);
  const downDir=normalize(bb.x-headX,bb.y-headY);
  const bisN=normalize(forkDir.x+downDir.x,forkDir.y+downDir.y);
  let stemDX=-bisN.x,stemDY=-bisN.y;
  if(stemDY>0){stemDX=-stemDX;stemDY=-stemDY}
  const stemLen=avgR*0.25;
  let stemTX=headX+stemDX*stemLen,stemTY=headY+stemDY*stemLen;
  const s2f=dist(stemTX,stemTY,fax,fay);
  if(s2f<rF+sw*2){
    const sd=normalize(stemTX-fax,stemTY-fay);
    stemTX=fax+sd.x*(rF+sw*2);stemTY=fay+sd.y*(rF+sw*2);
  }

  // Seat post top: constrain so seat centroid >= stem top Y (at or above handlebar)
  const spE=avgR*0.22;
  let stX=sj.x-Math.cos(seatAng)*spE,stY=sj.y-Math.sin(seatAng)*spE;
  stY=Math.min(stY,frameCeiling-avgR*0.05);
  // Seat centroid will be at stX, stY (pin point)
  // It must be at or above (<=) stemTY
  stY=Math.min(stY,stemTY);
  // Recompute stX to maintain seat angle
  const spActualLen=(sj.y-stY)/Math.sin(seatAng);
  stX=sj.x-Math.cos(seatAng)*spActualLen;

  // Colors
  const rearCol=getWheelColor(col,row,true,t,smooth.x,smooth.y);
  const frontCol=getWheelColor(col,row,false,t,smooth.x,smooth.y);

  // RENDER
  els.wheelRear.setAttribute('points',irregularNgon(rax,ray,rR,SEGMENTS,t*10+seed,seed,t));
  els.wheelRear.setAttribute('fill',rearCol);
  els.wheelFront.setAttribute('points',irregularNgon(fax,fay,rF,SEGMENTS,t*12.5+seed,seed+1,t));
  els.wheelFront.setAttribute('fill',frontCol);

  els.mainTriangle.setAttribute('points',`${sj.x},${sj.y} ${headX},${headY} ${bb.x},${bb.y}`);
  els.mainTriangle.setAttribute('stroke-width',sw);
  els.rearTriangle.setAttribute('points',`${sj.x},${sj.y} ${bb.x},${bb.y} ${rax},${ray}`);
  els.rearTriangle.setAttribute('stroke-width',sw);

  setLine(els.fork,headX,headY,fax,fay);els.fork.setAttribute('stroke-width',sw);
  setLine(els.seatPost,bb.x,bb.y,stX,stY);els.seatPost.setAttribute('stroke-width',sw);

  // Seat chevron
  const armLen=Math.max(avgR*0.25-3,4),ha=5*Math.PI/180;
  const pdx=stX-bb.x,pdy=stY-bb.y,pl=Math.sqrt(pdx*pdx+pdy*pdy)||1;
  const fwX=pdy/pl,fwY=-pdx/pl;
  const vx=stX-fwX*armLen*(2/3),vy=stY-fwY*armLen*(2/3);
  const uDX=fwX*Math.cos(-ha)-fwY*Math.sin(-ha),uDY=fwX*Math.sin(-ha)+fwY*Math.cos(-ha);
  const lDX=fwX*Math.cos(ha)-fwY*Math.sin(ha),lDY=fwX*Math.sin(ha)+fwY*Math.cos(ha);
  setLine(els.seatLower,vx,vy,vx+lDX*armLen,vy+lDY*armLen);els.seatLower.setAttribute('stroke-width',sw);
  setLine(els.seatUpper,vx,vy,vx+uDX*armLen,vy+uDY*armLen);els.seatUpper.setAttribute('stroke-width',sw);

  const crankR=clamp(avgR*0.1,vbH*0.004,vbH*0.035);
  els.crankset.setAttribute('points',irregularNgon(bb.x,bb.y,crankR,SEGMENTS,t*17.5+seed,seed+2,t));
  els.crankset.setAttribute('fill',DARK);

  setLine(els.stem,headX,headY,stemTX,stemTY);els.stem.setAttribute('stroke-width',sw);

  const dropR=clamp(avgR*0.12,vbH*0.004,vbH*0.035);
  const barExt=avgR*0.15,bfwd=(fax-rax)>0?1:-1;
  const bsx=stemTX+barExt*bfwd;
  els.dropBar.setAttribute('d',`M ${stemTX-avgR*0.04*bfwd},${stemTY} L ${bsx},${stemTY} A ${dropR} ${dropR} 0 1 1 ${bsx},${stemTY+dropR*2}`);
  els.dropBar.setAttribute('stroke-width',sw);
}

function update(){
  time+=0.008;
  smooth.x=lerp(smooth.x,input.x,0.055);
  smooth.y=lerp(smooth.y,input.y,0.055);
  for(let i=0;i<bikes.length;i++)updateBike(bikes[i],smooth.x,smooth.y,time);
  requestAnimationFrame(update);
}

document.addEventListener('mousemove',e=>{if(!useGyro){input.x=e.clientX/window.innerWidth;input.y=e.clientY/window.innerHeight}});
document.addEventListener('touchmove',e=>{if(!useGyro){const t=e.touches[0];input.x=t.clientX/window.innerWidth;input.y=t.clientY/window.innerHeight}},{passive:true});
function handleOrientation(e){input.x=clamp(((e.gamma||0)+40)/80,0,1);input.y=clamp(((e.beta||0)-20)/50,0,1)}
function initGyro(){useGyro=true;window.addEventListener('deviceorientation',handleOrientation,true);document.getElementById('motionPrompt').classList.remove('visible')}
function checkMotion(){
  if(!/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent))return;
  if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
    document.getElementById('motionPrompt').classList.add('visible');
    document.getElementById('motionBtn').addEventListener('click',async()=>{
      try{const p=await DeviceOrientationEvent.requestPermission();if(p==='granted')initGyro();else document.getElementById('motionPrompt').classList.remove('visible')}
      catch{document.getElementById('motionPrompt').classList.remove('visible')}
    });
  }else if('DeviceOrientationEvent'in window)initGyro();
}
checkMotion();requestAnimationFrame(update);
</script>
</body>
</html>
